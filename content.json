{"pages":[],"posts":[{"title":"js链式调用及delay函数实现","text":"今天在晚上看到一道JavaScript的面试题，感觉涉及到的知识点还是挺多的，在此记录一番。 先看下原题目123456789101112131415161718Person(\"Li\");// 输出： Hi! This is Li!Person(\"Jerry\").eat(\"dinner\").eat(\"supper\");// 输出：// Hi This is Jerry!// Eat dinner~Person(\"Dan\").sleep(10).eat(\"dinner\");// 输出：// Hi! This is Dan!// 等待10秒..// Wake up after 10// Eat dinner~Person(\"Cjc\").eat(\"dinner\").fristsleep(5).eat(\"supper\");// 输出：// 等待5s// Hi! This is Cjc!// Eat dinner~// Eat supper~ 第一眼看过去，这几个方法的都是需要链式调用来实现，而链式调用的核心是在函数中retrun this 大概思路有了，下面就来实现具体功能 12345678910111213// 首先来创建一个Person类 function Person(name) { console.log(`Hi This is ${name}`)}// 在Person类原型链上扩展eat方法Person.prototype.eat = function(food) { console.log(`Eat ${food}`) return this}// 在浏览器中测试 依次输出 // Hi This is Cjc! // Eat dinner~new Person('cjc').eat('dir') 简易版的链式调用实现了，但是看下题目中Person前面没有new运算符，这时候想起来设计模式中的工厂模式，在实例化对象外面包裹一层function，继续来改造下 123456789101112131415function Person(name) { return new Main(name)}function Main(name) { console.log(`Hi This is ${name}`)}Main.prototype.eat = function(food) { console.log(`Eat ${food}`) return this}// 在浏览器中测试 依次输出 // Hi This is Cjc! // Eat dinner~// 依旧OKPerson('cjc').eat('dir') 下面我们来看slee延迟函数的实现，延迟函数肯定是需要通过定时器来实现，但是由于setTimeout是一个异步线程，对js事件线程不熟悉的同学可以参考这两个文章视频再谈Event Loop和可视化Event Loop。异步线程里的所有事件都需要浏览器主线程事件执行完毕后才会去执行，这样一来链式调sleep函数内的事件顺序都会乱掉，没有达到延迟的作用。这时候就需要我们自己实现一个事件队列来控制函数的调用顺序和时机，。 下面看具体代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041function Person(name) { return new Main(name)}function Main(name) { this.queue = [] this.queue.push( () =&gt; { console.log(`Hi This is ${name}`) this.next() }) setTimeout( () =&gt; { this.next() })}Main.prototype.next = function() { let fn = this.queue.shift() if (typeof fn === 'function') { fn() }}Main.prototype.eat = function(food) { this.queue.push( () =&gt; { console.log(`Eat ${food}`) this.next() }) return this}Main.prototype.sleep = function(time) { this.queue.push( () =&gt; { setTimeout( () =&gt; { console.log(`Wake up after ${time}`) this.next() }, time * 1000) }) return this}// 在浏览器端测试 依次输出// This is cjc // 等待3秒// Wake up after 3Person('cjc').sleep(3).eat('dirner') 这段代码的增加了queue数组来存储事件列队，在每个事件函数最后添加this.next()，通过next函数依次从队列中取出函数不断的来调用，需要注意的是在Main函数中最后调用的this.next需要异步执行，否则在初始化调用this.next时queue事件列队为空。 这时基本的功能已经都实现了，还有一个fristsleep函数，将所有的事件都延迟执行，有了上面的铺垫这个实现起来就很简单了，我们只需在添加fristsleep函数时将this.queue.push改为unshift把事件添加到事件列队的第一位就OK了，下面看具体代码实现 12345678910// 添加代码Main.prototype.fristsleep = function(time) { this.queue.unshift( () =&gt; { setTimeout( () =&gt; { console.log(`Wake up after ${time}`) this.next() }, time * 1000) }) return this}","link":"/2019/05/13/js链式调用及delay函数实现/"}],"tags":[],"categories":[{"name":"杂谈","slug":"杂谈","link":"/categories/杂谈/"},{"name":"链式调用 事件队列","slug":"链式调用-事件队列","link":"/categories/链式调用-事件队列/"},{"name":"js","slug":"js","link":"/categories/js/"}]}